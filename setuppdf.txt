///////////////////application.pro
docs.file_path=C:\\Users\\Arpitsinh Chauhan\\Downloads\\


////////////////////////////////////////////////////////////////back
 @RequestMapping(value = "/pdfData", method = RequestMethod.POST)
    public byte[] authenticateUser(@RequestParam("fileName") String fileName) {
        if (fileName == null) {
            return null;
        }
        if (!fileName.endsWith(".pdf") && !fileName.endsWith(".PDF")) {
            fileName = fileName + ".pdf";
        }
        try (InputStream input = DBConfig.class.getClassLoader().getResourceAsStream("application.properties")) {
            StringBuilder filterData = new StringBuilder();
            Properties prop = new Properties();
            prop.load(input);
            filterData.append(prop.getProperty("docs.file_path"));
            //File pdf = new File(filterData + fileName);

            Path path = Paths.get(filterData.toString() + fileName);
            byte[] pdf = Files.readAllBytes(path);

            if (Objects.isNull(pdf)) {
                return null;
            }
            return pdf;

        } catch (IOException ex) {
            logger.error("authenticateUser0>>>>>>>>", ex);
        } catch (Exception ex) {
            logger.error("authenticateUser1>>>>>>>>", ex);
        }
        return null;
    }
}


////////////html
<input type="date" [(ngModel)]="selectedDate">
<button (click)="downloadReport()">Make API Call</button>

///////////
export class HomeComponent implements OnInit {

  pdfSrc = "https://vadimdez.github.io/ng2-pdf-viewer/assets/pdf-test.pdf";

  apiUrl = 'http://localhost:9999/all';
  // productList: Map<String, String> | undefined;
  productList: any = [];
  data: any;
  tableData: any[] = [];
  searchTerm: string = '';
  isProcessing: boolean | undefined;
  pd: any;

  // Product | undefined;
  // { id: any; Email: any; Phone: any } | undefined
  constructor(
    private http: HttpClient,
    private use: ServicesService,
    private dialog: MatDialog,// private pipe: FilterPipe
  ) { }






  ngOnInit(): void {
    // this.loadPdf('report_2024-04-17');
    this.getdata();
    this.dataSource = [
      /* Your data goes here */
    ];
  }

  getdata() {
    this.http.get(this.apiUrl).subscribe((data) => {
      this.productList = data;
      console.log(this.productList);
    });
  }
  deleteRow(id: number) {
    console.log(id);
    alert('Product deleted successfully');
    this.use.deleteMember(id).subscribe((result) => {
      this.productList = result;
    });
    location.reload();
  }

  Update(id: number) {
    let current = this.productList.find((p: any) => {
      // alert('Your data succefully Update');
      return p.id = id;
    });
    console.log(current);
  }

  dataSource: any[] | undefined; // Your data source array
  currentPage = 1; // Current page index
  itemsPerPage = 5; // Number of items per page

  applyFilter(filterValue: string) {
    filterValue = filterValue.trim(); // Remove whitespace
    filterValue = filterValue.toLowerCase(); // Datasource defaults to lowercase matches
    this.productList.filter = filterValue;
  }

  // filteredItems: any[] = [];
  // filterItems(searchTerm: string): void {
  //   this.filteredItems = this.productList.filter(
  //     (filterItems: { name: string | string[] }) => {
  //       filterItems.name.includes(searchTerm);
  //     }
  //   );
  // }

  search(): void {
    this.productList = this.productList.filter((item: { email: string }) =>
      item.email.toLowerCase().includes(this.searchTerm.toLowerCase().trim())
    );
    if (this.searchTerm.toLowerCase() === '') {
      location.reload();
    }
  }
  reportUrl: string | undefined;


  // fetchReport() {
  //   const headers = new HttpHeaders({ 'Content-Type': 'application/pdf' });
  //   this.http.get('http://localhost:8080/api/bill', { headers: headers, responseType: 'blob' })
  //     .subscribe((response: any) => {
  //       const file = new Blob([response], { type: 'application/pdf' });
  //       this.reportUrl = URL.createObjectURL(file);
  //     });
  // }


  selectedDate!: Date | null;

  // Function to handle date selection
  dateSelected(event: MatDatepickerInputEvent<Date>) {
    this.selectedDate = event.value;
  }
 
  downloadReport(): void {
    if (!this.selectedDate) {
      console.error('Please select a date');
      return;
    }
    // Make API call to download the PDF
    this.isProcessing = true;
    this.downloadPDF();
  }

  downloadPDF() {
    // Construct the API URL with the selected date
    const apiUrl = `http://localhost:9090/api/bill?date=${this.selectedDate}`;

    // Make a GET request to the API endpoint to download the PDF
    fetch(apiUrl, {
      method: 'GET',
    })
      .then(response => {
        // Check if the response is successful
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.blob(); // Extract the binary data from the response
      })
      .then(blob => {
        // Create a blob URL for the PDF
        const url = window.URL.createObjectURL(blob);

        // Create a temporary <a> element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = `${this.selectedDate}.pdf`; // Set filename with date
        document.body.appendChild(a);
        a.click();

        // Clean up by revoking the blob URL and removing the <a> element
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
        this.openPdfViewer();
      })
      .catch(error => {
        // Handle any errors
        console.error('Error downloading PDF:', error);
      });
  }

  openPDFViewerComponent(fileName: string, pdfData: any) {
    const dialogRef = this.dialog.open(CustomPdfViewerComponent, {
      maxWidth: '100%',
      maxHeight: '100%',
      width: '60%',
      height: '50%',
      data: {
        pdfData: pdfData,
        title: fileName,
        selectedDate: this.selectedDate
      }
    });
    // After the PDF viewer component is closed, initiate the download
    dialogRef.afterClosed().subscribe(() => {
      this.PDF(fileName, pdfData);
    });
  }

  PDF(fileName: string, pdfData: any) {
    // Create a blob from PDF data
    const blob = new Blob([pdfData], { type: 'application/pdf' });

    // Create a temporary link element
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = fileName;

    // Append the link to the document and trigger a click event to start download
    document.body.appendChild(link);
    link.click();
  }

  openPdfViewer(){
    let fileName1 = `${this.selectedDate}.pdf`;
    this.use.getPDFData(fileName1).subscribe(
      (response: ArrayBuffer) => {
        if(response.byteLength!=0){
          // Open the custom PDF viewer component with PDF data
          this.openPDFViewerComponent(`${this.selectedDate}.pdf`, response);
        }else{
          this.openPdfViewer();
        }
      },
      (error: any) => {
        console.error('Error fetching PDF:', error);
        this.isProcessing = false;
      }
    );
  }

}


////////////////////////////
<h1>pdf</h1>
<div>
    <!-- <button (click)="downloadPDF()">Download PDF</button> -->
    <div class="pdf-container" style="width: 103%;">
        <pdf-viewer [src]="pdfDocumentSrc" [rotation]="0" [original-size]="false" [show-all]="true"
            [fit-to-page]="false" [zoom]="zoom_to" [zoom-scale]="'page-width'" [stick-to-page]="false"
            [render-text]="true" [external-link-target]="'blank'" [autoresize]="true" [show-borders]="false"
            class="viewer"></pdf-viewer>
    </div>
</div>  

////////////////

export class CustomPdfViewerComponent implements OnInit {

  src: any;
  title;
  zoom_to = 1;

  @ViewChild(CustomPdfViewerComponent) private pdfComponent: CustomPdfViewerComponent | undefined;
  searchText = '';
  pdfFindController: any;
  data: any;
  selectedDate: any;

  constructor(public dialogRef: MatDialogRef<CustomPdfViewerComponent>,
    @Inject(MAT_DIALOG_DATA) data: any, private spinnerService: NgxSpinnerService) {
    this.pdfDocumentSrc = data.pdfData;
    this.title = data.title;
    this.selectedDate = data.selectedDate;
    setTimeout(() => {
      // this.loaderService.display(false);
    }, 1000);
  }

  applyFilter(event: string, findPrevious?: boolean | undefined) {
    console.log(event);
    const filterValue = event;
    if (this.pdfComponent) {
      if (this.searchText !== filterValue) {
        this.searchText = filterValue;

        this.pdfComponent.pdfFindController.executeCommand('find', {
          query: this.searchText,
          highlightAll: true
        });
      } else {
        this.searchText = filterValue;
        this.pdfComponent.pdfFindController.executeCommand('findagain', {
          query: this.searchText,
          highlightAll: true,
          findPrevious: findPrevious ? this.searchText : undefined
        });
      }
    }
  }


  onKeyDownHandler(event: { target: { value: string; }; }) {
    this.applyFilter(event.target.value);
  }

  onDescClick() {
    this.applyFilter(this.searchText);
  }

  onAscClick() {
    this.applyFilter(this.searchText, true);
  }

  onInputChange(event: { target: { value: string; }; }) {
    this.applyFilter(event.target.value);
  }

  pdfDocumentSrc: any;
  page: number = 1;
  totalPages: number = 0;
  isLoaded: boolean = false;

  afterLoadComplete(pdfData: any) {
    this.totalPages = pdfData.numPages;
    this.isLoaded = true;
  }

  nextPage() {
    this.page++;
  }

  prevPage() {
    this.page--;
  }

  ngOnInit(): void {
  }

  close() {
    this.dialogRef.close();
  }

  zoom_in() {
    this.zoom_to = this.zoom_to + 0.25;
  }

  zoom_out() {
    if (this.zoom_to > 0.25) {
      this.zoom_to = this.zoom_to - 0.25;
    }
  }
  // downloadPDF() {

  //   // Construct the API URL with the selected date
  //   const apiUrl = `http://localhost:9090/api/bill?date=${this.selectedDate}`;

  //   // Make a GET request to the API endpoint to download the PDF
  //   fetch(apiUrl, {
  //     method: 'GET',
  //   })
  //     .then(response => {
  //       // Check if the response is successful
  //       if (!response.ok) {
  //         throw new Error('Network response was not ok');
  //       }
  //       return response.blob(); // Extract the binary data from the response
  //     })
  //     .then(blob => {
  //       // Create a blob URL for the PDF
  //       const url = window.URL.createObjectURL(blob);

  //       // Create a temporary <a> element to trigger the download
  //       const a = document.createElement('a');
  //       a.href = url;
  //       a.download = `${this.selectedDate}.pdf`; // Set filename with date
  //       document.body.appendChild(a);
  //       a.click();

  //       // Clean up by revoking the blob URL and removing the <a> element
  //       window.URL.revokeObjectURL(url);
  //       document.body.removeChild(a);
  //     })
  //     .catch(error => {
  //       // Handle any errors
  //       console.error('Error downloading PDF:', error);
  //     });
  // }
}

getPDFData(fileName: string | number | boolean): Observable<any> {
    const param = new HttpParams().set("fileName", fileName);
    return this.http.post('http://localhost:9090/pdfData', null, {
      responseType: "arraybuffer",
      params:param,
      headers: new HttpHeaders().append("Content-Type", "application/pdf"),
    });
  }

 "ng2-pdf-viewer": "^10.0.0",
    "ngx-pagination": "^6.0.3",
    "ngx-spinner": "^16.0.2",


public class DBConfig {

    private static String url = "";
    private static String username = "";
    private static String password = "";
    private static String driver = "";
    private static boolean flag = false;

    public DBConfig() {
        configureProperties();
    }

    private void configureProperties() {
        if (!flag) {
            try (InputStream input = DBConfig.class.getClassLoader().getResourceAsStream("application.properties")) {
                Properties prop = new Properties();
                // load a properties file
                prop.load(input);
                url = prop.getProperty("spring.datasource.url");
                username = prop.getProperty("spring.datasource.username");
                password = prop.getProperty("spring.datasource.password");
                driver = prop.getProperty("spring.datasource.driver-class-name");
                flag = true;
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }

    }

    public static Connection getConnection() throws ClassNotFoundException, SQLException {
        Connection connection = null;
        Class.forName(driver);
        connection = DriverManager.getConnection(url, username, password);
        return connection;
    }

}

  @PostMapping("/kharch")
    public void receiveExpenses(@RequestBody List<kharch> expenses) {
        for (kharch expense : expenses) {
            expense.setDate(expense.getDate()); // Set the date
            expense.setNotes(expense.getNotes()); // Set the notes
            expense.setPrice(expense.getPrice());
            System.out.println(expense);
            kharchRepository.save(expense);
        }
    }

 total = 0;
  selectedDate!: Date | null;
  purchaDipStockseDetails: any = {
    date: ''
  };
  // row = [
  //   {
  //     id: '',
  //     date: this.purchaDipStockseDetails.date,
  //     notes: '',
  //     price: '',
  //   },
  // ];

  constructor(private http: HttpClient) {
  }

  ngOnInit() {
    this.row[0].idkharch = '1';
  }
  order() {
    const data = {
      // date: this.purchaDipStockseDetails.date,
      expenses: this.row
    };



    // Send data to backend
    this.http.post<any>('http://localhost:9090/kharch', this.row)
      .subscribe(response => {
        // const responseData = response.expenses;
        this.purchaDipStockseDetails.date = null;
        this.row = [];
      });
  }
  purchaseDetails: any = {
    date: '' // You can set default date if needed
  };
  row: any[] = [];
  lastRowId: number = 0;

  addTable() {
    // Add a new row to the table
    this.lastRowId++;
    // this.row.push({ id: '', date: this.purchaDipStockseDetails.date, notes: '', price: '' });
    const newRow = { idkharch: this.lastRowId,  date: this.purchaDipStockseDetails.date,notes: '', price: '' };
    this.row.push(newRow);
  }

  deleteRow(index: number) {
    // Remove a row from the table
    this.row.splice(index, 1);
  }
}

/////////////////////jama baki componenet
<input type="date" [(ngModel)]="purchaDipStockseDetails.date">

<div style="display:inline;width:100%">
    <div style="display:inline;">
        <button (click)="addTable()">Add Row</button>
    </div>
    <div style="display:inline;margin-left:45%">
        <button (click)="order()">Order</button>
    </div>
</div>
<br />
<table class="style">
    <tr>
        <th style="max-width:60px">RowId</th>
        <th>Sender</th>
        <th>Receiver</th>
        <th>Amount</th>
        <th></th>
    </tr>
    <tr *ngFor="let item of row; let i = index">
        <td><input type="text" [(ngModel)]="item.idkharch" /></td>
        <td><input type="text" [(ngModel)]="item.sender" /></td>
        <mat-form-field style="margin-top: 4%; background-color: rgb(252, 252, 252);">
            <mat-label>Receiver</mat-label>
            <mat-select  [(ngModel)]="item.receiver">
                <mat-option *ngFor="let name of names" [value]="name">
                    {{ name }}
                </mat-option>
            </mat-select>
        </mat-form-field>
        <td><input type="text" [(ngModel)]="item.amount" /></td>
        <td>
            <button (click)="deleteRow(i)"><i class="fa fa-trash"></i></button>
        </td>
    </tr>
    <tr>
        GrandTotal:
        <input type="text" />
    </tr>
</table>

export class SendmoneyComponent {
  total = 0;
  selectedDate!: Date | null;
  purchaDipStockseDetails: any = {
    date: ''
  };
  // row = [
  //   {
  //     id: '',
  //     date: this.purchaDipStockseDetails.date,
  //     notes: '',
  //     price: '',
  //   },
  // ];

  constructor(@Inject(MAT_DIALOG_DATA) public data: any,
    private http: HttpClient,
    private use: ServicesService,
    private dialog: MatDialog,
  ) {
    console.log(data);

  }


  ngOnInit() {
    this.getdata();
    // this.row[0].idkharch = '1';
  }
  names: any[] = [];
  getdata() {
    this.http.get<any>('http://localhost:9090/Customerall')
      .subscribe(response => {
        this.names = Object.values(response).map((item: any) => item.name);
      });
  }



  // addTable() {
  //   console.log(this.row.length);
  //   const obj = {
  //     id: '',
  //     date: this.purchaDipStockseDetails.date,
  //     notes: '',
  //     price: '',
  //   };

  //   this.row.push(obj);
  //   this.row[this.row.length - 1].id = this.row.length.toString();
  // }

  // deleteRow(x: number) {
  //   var delBtn = confirm(' Do you want to delete ?');
  //   if (delBtn == true) {
  //     this.row.splice(x, 1);
  //   }
  // }

  order() {
    const data = {
      // date: this.purchaDipStockseDetails.date,
      expenses: this.row
    };

    console.log(this.row);


    // Send data to backend
    this.http.post<any>('http://localhost:9090/jamabakiadd', this.row)
      .subscribe(response => {
        // const responseData = response.expenses;
        this.purchaDipStockseDetails.date = null;
        this.row = [];
      });
  }
  purchaseDetails: any = {
    date: '' // You can set default date if needed
  };
  row: any[] = [];
  lastRowId: number = 0;

  addTable() {
    // Add a new row to the table
    this.lastRowId++;
    // this.row.push({ id: '', date: this.purchaDipStockseDetails.date, notes: '', price: '' });
    const newRow = { idkharch: this.lastRowId, date: this.purchaDipStockseDetails.date, sender: this.data.name, receiver: this.names, amount: '' };
    this.row.push(newRow);
  }

  deleteRow(index: number) {
    // Remove a row from the table
    this.row.splice(index, 1);
  }
  dataSource = [

  ];
}
  @PostMapping("/jamabakiadd")
    public void receivejamabakiadd(@RequestBody List<jamabaki> expenses) {
        for (jamabaki expense : expenses) {
            expense.setDate(expense.getDate()); // Set the date
            expense.setSender(expense.getSender()); // Set the notes
            expense.setReceiver(expense.getReceiver());
            expense.setAmount(expense.getAmount());
            System.out.println(expense.toString());
            JamabakiRepository.save(expense);
        }
    }
/////////////
<mat-form-field>
                <input matInput [(ngModel)]="purchaDipStockseDetails.date" type="date" (change)="updateDate()">
              </mat-form-field>

//////////////////
updateDate() {
    // Update the date field in each row with the selected date
    this.row.forEach(row => {
      row.date = this.purchaDipStockseDetails.date;
    });
  }
 purchaDipStockseDetails = {
    date: ''
  };

  row = [
    {
      type: 'Petrol',
      quantity: '',
      total: '',
      vat: '',
      cess: '',
      total_purchase: '',
      date: ''
    },
    {
      type: 'Diesel',
      quantity: '',
      total: '',
      vat: '',
      cess: '',
      total_purchase: '',
      date: ''
    }
  ];

/////////////////////
SELECT * FROM practice.dailytotal
WHERE date = DATE_FORMAT(CURDATE(), '%d/%m/%Y');

SELECT SUM(total_rs) AS total_sum
FROM practice.dailytotal
WHERE MONTH(STR_TO_DATE(date, '%d/%m/%Y')) = MONTH(CURDATE());


SELECT * FROM practice.dailytotal
where YEAR(STR_TO_DATE(date, '%d/%m/%Y')) = YEAR(CURDATE());

SELECT SUM(total_rs) AS total_sum FROM practice.dailytotal
where YEAR(STR_TO_DATE(date, '%d/%m/%Y')) = YEAR(CURDATE());



